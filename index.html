<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DABBADOO: FINAL SIGMA</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: 'Black Ops One', system-ui; }
        
        /* Orientation Force */
        #lock { position: fixed; inset: 0; background: #000; color: #f00; z-index: 1000; display: none; align-items: center; justify-content: center; text-align: center; border: 10px solid #f00; }
        @media (orientation: portrait) { #lock { display: flex; } }

        /* HUD */
        #hud { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; }
        .stat { color: #0f0; font-size: 22px; text-shadow: 2px 2px #000; margin-bottom: 5px; }
        #hp-bg { width: 200px; height: 12px; background: rgba(0,0,0,0.5); border: 2px solid #fff; }
        #hp-val { width: 100%; height: 100%; background: #f00; transition: 0.2s; }

        /* Buttons */
        .btn { position: absolute; z-index: 20; border-radius: 50%; border: 3px solid #fff; color: #fff; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.4); font-size: 14px; }
        #jump-btn { bottom: 120px; right: 40px; width: 80px; height: 80px; background: #4400ff; }
        #shoot-btn { bottom: 20px; right: 30px; width: 110px; height: 110px; background: #ff0044; border-color: #ff0; font-size: 20px; }

        /* FIXED JOYSTICK */
        #joy-base { position: absolute; bottom: 30px; left: 30px; width: 130px; height: 130px; background: rgba(255,255,255,0.1); border: 2px solid #0ff; border-radius: 50%; z-index: 20; }
        #joy-knob { position: absolute; top: 40px; left: 40px; width: 50px; height: 50px; background: #0ff; border-radius: 50%; box-shadow: 0 0 15px #0ff; }

        #win-screen { position: fixed; inset: 0; background: rgba(0,0,0,0.8); color: #fff; display: none; align-items: center; justify-content: center; flex-direction: column; z-index: 500; font-size: 50px; text-shadow: 0 0 20px #0f0; }
    </style>
</head>
<body>
    <div id="lock"><h1>ROTATE SCREEN BRO!<br>SIGMAS PLAY HORIZONTAL</h1></div>
    <div id="win-screen"><h1>THX BRO!</h1><p style="font-size: 20px;">VULVIAN LEVEL UP</p></div>

    <div id="hud">
        <div class="stat">VULVIAN LVL: <span id="vlvl">1</span></div>
        <div id="hp-bg"><div id="hp-val"></div></div>
    </div>

    <div id="joy-base"><div id="joy-knob"></div></div>
    <div id="jump-btn" class="btn">JUMP</div>
    <div id="shoot-btn" class="btn">SNOT</div>

    <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
    <script>
        /** ENGINE INITIALIZATION **/
        let scene, camera, renderer, clock, gun;
        let platforms = [], enemies = [], bullets = [];
        let vLvl = 1, hp = 100, isPlaying = true, jumps = 0, velY = 0;
        let move = { x: 0, y: 0 }, look = { x: 0, y: 0 };
        let touches = { move: null, look: null, lx: 0, ly: 0 };
        let boobi, cage;

        init();
        animate();

        function createStarBox() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#050010'; ctx.fillRect(0,0,512,512);
            for(let i=0; i<200; i++) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(5, 5);
            return tex;
        }

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            
            // INCREASED FOV TO 90
            camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // SKYBOX
            const skyGeo = new THREE.SphereGeometry(500, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({ map: createStarBox(), side: THREE.BackSide });
            scene.add(new THREE.Mesh(skyGeo, skyMat));

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            const sun = new THREE.DirectionalLight(0x00ff00, 1);
            sun.position.set(5, 10, 5);
            scene.add(ambient, sun);

            // GUN
            gun = new THREE.Group();
            const gBody = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.7), new THREE.MeshStandardMaterial({color: 0x222222}));
            const gMuzzle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.2), new THREE.MeshStandardMaterial({color: 0x00ff00}));
            gMuzzle.position.z = -0.4;
            gun.add(gBody, gMuzzle);
            gun.position.set(0.4, -0.3, -0.5);
            camera.add(gun);
            scene.add(camera);

            generateLevel();
            setupControls();
            window.addEventListener('resize', onResize);
        }

        function generateLevel() {
            platforms.forEach(p => scene.remove(p));
            enemies.forEach(e => scene.remove(e));
            if(cage) scene.remove(cage);
            platforms = []; enemies = [];
            
            camera.position.set(0, 5, 0);
            isPlaying = true;

            // Start
            addBlock(0, 0, 0, 15, 15, 0x333333);

            let z = -15;
            let y = 0;
            const count = 5 + (vLvl * 2);

            for(let i=0; i<count; i++) {
                let x = (Math.random()-0.5) * 12;
                y += (Math.random()-0.2) * 3;
                z -= 15;
                addBlock(x, y, z, 10, 10, 0x0066ff);
                if(i % 2 === 1) spawnMob(x, y+3, z);
            }

            // Goal
            z -= 20;
            addBlock(0, y, z, 15, 15, 0xff0066);
            spawnRescue(0, y+2, z);
        }

        function addBlock(x, y, z, w, d, col) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(w, 2, d), new THREE.MeshStandardMaterial({color: col, emissive: col, emissiveIntensity: 0.2}));
            b.position.set(x, y, z);
            // PROPER BOX HITBOX
            b.userData.bounds = { xMin: x-w/2, xMax: x+w/2, zMin: z-d/2, zMax: z+d/2, y: y+1 };
            scene.add(b);
            platforms.push(b);
        }

        function spawnMob(x, y, z) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({color: 0xff4400}));
            m.position.set(x, y, z);
            m.userData = { hp: 1 + vLvl, speed: 0.05 + (vLvl*0.01) };
            scene.add(m);
            enemies.push(m);
        }

        function spawnRescue(x, y, z) {
            cage = new THREE.Mesh(new THREE.BoxGeometry(5, 6, 5), new THREE.MeshStandardMaterial({color: 0xffffff, wireframe: true}));
            cage.position.set(x, y+2, z);
            boobi = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1), new THREE.MeshStandardMaterial({color: 0xff0000}));
            boobi.position.copy(cage.position);
            scene.add(cage, boobi);
        }

        function setupControls() {
            const joy = document.getElementById('joy-base'), knob = document.getElementById('joy-knob');
            
            window.addEventListener('touchstart', e => {
                for(let t of e.changedTouches) {
                    let r = joy.getBoundingClientRect();
                    if(t.clientX > r.left && t.clientX < r.right && t.clientY > r.top && t.clientY < r.bottom) {
                        touches.move = t.identifier;
                    } else if(!touches.look) {
                        touches.look = t.identifier;
                        touches.lx = t.clientX; touches.ly = t.clientY;
                    }
                }
            }, {passive: false});

            window.addEventListener('touchmove', e => {
                for(let t of e.changedTouches) {
                    if(t.identifier === touches.move) {
                        let r = joy.getBoundingClientRect();
                        let dx = t.clientX - (r.left + 65), dy = t.clientY - (r.top + 65);
                        let dist = Math.min(Math.sqrt(dx*dx+dy*dy), 55);
                        let angle = Math.atan2(dy, dx);
                        knob.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
                        move.x = Math.cos(angle) * (dist/55); move.y = -Math.sin(angle) * (dist/55);
                    }
                    if(t.identifier === touches.look) {
                        look.x -= (t.clientX - touches.lx) * 0.25;
                        look.y -= (t.clientY - touches.ly) * 0.25;
                        touches.lx = t.clientX; touches.ly = t.clientY;
                    }
                }
            }, {passive: false});

            window.addEventListener('touchend', e => {
                for(let t of e.changedTouches) {
                    if(t.identifier === touches.move) { 
                        touches.move = null; move.x = 0; move.y = 0; knob.style.transform = `translate(0,0)`;
                    }
                    if(t.identifier === touches.look) touches.look = null;
                }
            });

            document.getElementById('jump-btn').ontouchstart = () => { if(jumps < 2) { velY = 0.35; jumps++; } };
            document.getElementById('shoot-btn').ontouchstart = fire;
        }

        function fire() {
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            b.position.copy(camera.position);
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            b.userData.v = dir.multiplyScalar(2.5);
            scene.add(b); bullets.push(b);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isPlaying) return;

            // Rotation
            look.y = Math.max(-85, Math.min(85, look.y));
            camera.rotation.order = 'YXZ';
            camera.rotation.y = THREE.MathUtils.degToRad(look.x);
            camera.rotation.x = THREE.MathUtils.degToRad(look.y);

            // Movement
            let forward = new THREE.Vector3(move.x, 0, -move.y).applyQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), camera.rotation.y));
            camera.position.add(forward.multiplyScalar(0.25));

            // FIXED PHYSICS
            velY -= 0.016;
            camera.position.y += velY;

            platforms.forEach(p => {
                const b = p.userData.bounds;
                if(camera.position.x > b.xMin && camera.position.x < b.xMax && 
                   camera.position.z > b.zMin && camera.position.z < b.zMax) {
                    if(camera.position.y > b.y && camera.position.y < b.y + 2) {
                        camera.position.y = b.y + 0.8;
                        velY = 0; jumps = 0;
                    }
                }
            });

            if(camera.position.y < -40) { hp -= 25; camera.position.set(0, 10, 0); updateHUD(); }

            // Enemies
            enemies.forEach(e => {
                let d = e.position.distanceTo(camera.position);
                if(d < 25) {
                    e.lookAt(camera.position.x, e.position.y, camera.position.z);
                    e.position.add(new THREE.Vector3().subVectors(camera.position, e.position).normalize().multiplyScalar(e.userData.speed));
                    if(d < 2) { hp -= 0.5; updateHUD(); }
                }
            });

            // Bullets
            bullets.forEach((b, i) => {
                b.position.add(b.userData.v);
                enemies.forEach((e, j) => {
                    if(b.position.distanceTo(e.position) < 2) {
                        scene.remove(e); enemies.splice(j,1);
                        scene.remove(b); bullets.splice(i,1);
                    }
                });
            });

            // Boobi Animation
            if(boobi) boobi.position.y += Math.sin(Date.now()*0.005)*0.01;

            if(boobi && camera.position.distanceTo(boobi.position) < 5) win();

            renderer.render(scene, camera);
        }

        function updateHUD() {
            document.getElementById('hp-val').style.width = hp + "%";
            if(hp <= 0) { alert("GRIND OVER. TRY AGAIN."); location.reload(); }
        }

        function win() {
            isPlaying = false;
            vLvl++;
            document.getElementById('vlvl').innerText = vLvl;
            document.getElementById('win-screen').style.display = 'flex';
            setTimeout(() => {
                document.getElementById('win-screen').style.display = 'none';
                generateLevel();
            }, 2000);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
